<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="in.hocg.basic.NodeMapper">

    <sql id="table">
        tree `${alias}`
    </sql>
    <sql id="columns">
        ${alias}.*
    </sql>

    <!--树节点相关 start-->
    <insert id="appendChild">
        UPDATE tree
        SET rgt = rgt + 2
        WHERE rgt > #{lft};

        UPDATE tree
        SET lft = lft + 2
        WHERE lft > #{lft};
    </insert>

    <insert id="afterChild">
        UPDATE tree
        SET rgt = rgt + 2
        WHERE rgt > #{rgt};

        UPDATE tree
        SET lft = lft + 2
        WHERE lft > #{rgt};
    </insert>
    <delete id="emptyNode">
        DELETE
        FROM tree
        WHERE lft BETWEEN #{left} AND #{right};

        UPDATE tree
        SET rgt = rgt - #{width}
        WHERE rgt > #{right};

        UPDATE tree
        SET lft = lft - #{width}
        WHERE lft > #{left};
    </delete>
    <delete id="deleteNode">
        DELETE
        FROM tree
        WHERE lft = #{left};

        UPDATE tree
        SET rgt = rgt - 1,
            lft = lft - 1
        WHERE lft BETWEEN #{left} AND #{right};

        UPDATE tree
        SET rgt = rgt - 2
        WHERE rgt > #{right};

        UPDATE nested_category
        SET lft = lft - 2
        WHERE lft > #{right};
    </delete>
    <select id="queryNodeAndChildren"
            resultType="in.hocg.module.example.entity.Tree">
        <![CDATA[
        SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth
        FROM tree AS node,
             tree AS parent,
             tree AS sub_parent,
             (SELECT node.name, (COUNT(parent.name) - 1) AS depth
              FROM tree AS node,
                   tree AS parent
              WHERE node.lft BETWEEN parent.lft AND parent.rgt
                AND node.id = #{id}
              GROUP BY node.name
              ORDER BY node.lft) AS sub_tree
        WHERE node.lft BETWEEN parent.lft AND parent.rgt
          AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt
          AND sub_parent.name = sub_tree.name
        GROUP BY node.name
        HAVING depth <= 1
        ORDER BY node.lft;
        ]]>
    </select>
    <select id="queryAllChildren"
            resultType="in.hocg.module.example.entity.Tree">
        SELECT node.name
        FROM tree AS node,
             tree AS parent
        WHERE node.lft BETWEEN parent.lft AND parent.rgt
          AND parent.id = #{id}
        ORDER BY node.lft;
    </select>
    <select id="queryAllLeafNode" resultType="in.hocg.module.example.entity.Tree">
        SELECT name
        FROM tree
        WHERE rgt = lft + 1;
    </select>
    <select id="queryTreeNodeForLeaf" resultType="in.hocg.module.example.entity.Tree">
        SELECT parent.name
        FROM tree AS node,
             tree AS parent
        WHERE node.lft BETWEEN parent.lft AND parent.rgt
          AND node.id = #{id}
        ORDER BY parent.lft;
    </select>
    <select id="queryAllNodeDepth" resultType="in.hocg.module.example.entity.Tree">
        SELECT node.name, (COUNT(parent.name) - 1) AS depth
        FROM tree AS node,
             tree AS parent
        WHERE node.lft BETWEEN parent.lft AND parent.rgt
        GROUP BY node.name
        ORDER BY node.lft;
    </select>
    <select id="queryTreeNodeDepth" resultType="in.hocg.module.example.entity.Tree">
        SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth
        FROM tree AS node,
             tree AS parent,
             tree AS sub_parent,
             (SELECT node.name, (COUNT(parent.name) - 1) AS depth
              FROM tree AS node,
                   tree AS parent
              WHERE node.lft BETWEEN parent.lft AND parent.rgt
                AND node.id = #{id}
              GROUP BY node.name
              ORDER BY node.lft) AS sub_tree
        WHERE node.lft BETWEEN parent.lft AND parent.rgt
          AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt
          AND sub_parent.name = sub_tree.name
        GROUP BY node.name
        ORDER BY node.lft;
    </select>
    <select id="analysis" resultType="java.lang.String">
        SELECT CONCAT(REPEAT(' ', COUNT(parent.name) - 1), node.name) AS name
        FROM tree AS node,
             tree AS parent
        WHERE node.lft BETWEEN parent.lft AND parent.rgt
        GROUP BY node.id
        ORDER BY node.lft;
    </select>
    <!--树节点相关 end-->
</mapper>
